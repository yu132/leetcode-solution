/**  
 * @ClassName: package-info  
 *
 * @Description: TODO(这里用一句话描述这个类的作用)  
 *
 * @author 余定邦  
 *
 * @date 2021年1月15日  
 *  
 */
package redo.Util.ag.array.maxWidthRamp;

/*
 * 最大宽坡问题，即求当nums[i]<nums[j]的情况下的j-i的最大值
 * 
 * 思想是使用递减栈（和一般的单调栈不一样）来处理这个问题
 * 
 * 首先是将所有小于当前栈顶的元素（其实是压入索引，元素值总数组中取出）压入（和一般的单调栈不同）
 * 一般的单调栈是栈内元素不符合要求，将其弹出并压入新的元素，
 * 而此处的递减栈是保留栈内元素，不压入不符合要求的元素，
 * 这是因为题目的特性而决定的，一个出现在更前面并且更小的元素总是比更大出现在更后面的元素更有用
 * 
 * 然后我们逆序遍历整个数组，如果当前栈顶的值比当前值要小，那么我们弹出栈顶，并计算一次j-i并更新最大值
 * 
 * 为什么如果栈顶比当前值小就可以弹出？假设前面有一个比这个值还小的元素，那么这个元素是毫无意义的
 * 因为当前值更大，并且对应的j也更大，因此总是能得到一个更大的j-i作为结果
 * 
 * 假设前面有一个更大的元素，那么这个元素就有可能产生更大的结果，但是由于这个元素对应的j1<j
 * 因此对于当前的栈顶i，j1-i<j-i，所以对于比当前元素更小的栈顶也不能和之前的更大的元素产生大于j-i的答案
 * 只有出现j1-i1>j-i的情况下，才能更新答案，而对于比当前元素更小的栈顶，是不可能为这个i1的，而只能为i
 * 因此我们可以随意的抛弃比当前值更小的栈顶，因为只有更大的栈顶才能和前面的更大的值产生更大的结果
 * 
 * 时间复杂度为O(n)，即遍历数组生成递减栈和逆序遍历数组，弹出栈中元素的过程
 * 空间为O(n)
 */
