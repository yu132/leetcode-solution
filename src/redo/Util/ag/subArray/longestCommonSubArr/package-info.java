/**  
 * @ClassName: package-info  
 *
 * @Description: TODO(这里用一句话描述这个类的作用)  
 *
 * @author 余定邦  
 *
 * @date 2021年1月19日  
 *  
 */
package redo.Util.ag.subArray.longestCommonSubArr;

/*
 * 思路有两种比较方便且不同的方法，第一种是将最长公共子序列中的递推式进行一些修改,
 * 修改是因为如果不相同，那么前面的计数都作废了，不再有效，而不像子序列一样可以接着前面继续计算
 * 
 *          {   0                           if  i==0 || j==0
 *  c[i,j]= {   c[i-1,j-1]+1                if  i>0 && j>0 && a[i]=b[j]
 *          {   0                           if  i>0 && j>0 && a[i]!=b[j]
 *          
 * 即可完成本题，例子见leetcode-718
 * 
 * 另一种方式是通过滚动哈希+二分查找的思想
 * 本问题可以理解为找到最大的（符合存在两个子数组相同的）长度
 * 对于较大的长度成立时，较小的长度也一定成立，因此可以使用二分查找
 * 
 * 对于每种长度，使用求滚动哈希时间为和长度相关，比较哈希表中是否存在相同的值是O(1)
 * 而二分的范围是0-长度，因此时间复杂度为O(n*log(n))
 */
