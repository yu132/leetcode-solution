/**  
 * @ClassName: package-info  
 *
 * @Description: TODO(这里用一句话描述这个类的作用)  
 *
 * @author 余定邦  
 *
 * @date 2021年1月5日  
 *  
 */
package redo.Util.ag.subArray.subArrayInSum;

/*
 * 和为某值的所有子数组，求出所有子数组和为sum的所有子数组，返回子数组数量或者返回子数组的边界
 * 
 * 比较暴力的方法是对于每两个索引，检查从i到j的子数组的和是否为sum
 * 如果是则加入答案中，很明显这样做是O(n^3)的
 * 
 * 一个优化是先求出前缀和数组，那么求i到j范围的子数组和的时间则会变为O(1)，此时时间复杂度下降到O(n^2)
 * 
 * 当然，有更简单的方法，即将0-i的前缀和加入到一个Map中，当我们遍历到0-j的情况时，
 * 如果存在0-i的前缀和为sum - sum(0-j)时，i-j的前缀和即为sum，此时就是一个答案
 */
